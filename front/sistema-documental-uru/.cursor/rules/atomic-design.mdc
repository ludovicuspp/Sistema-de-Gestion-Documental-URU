---
description: Arquitectura Atomic Design para organización de componentes React
alwaysApply: true
---

# Atomic Design Architecture

Este proyecto utiliza **Atomic Design** como metodología de organización de componentes. Todos los componentes deben seguir esta estructura jerárquica.

## Estructura de Carpetas

```
src/
  components/
    atoms/          # Componentes básicos e indivisibles
    molecules/      # Combinaciones simples de átomos
    organisms/      # Componentes complejos (secciones de UI)
    templates/      # Layouts y estructuras de página
    pages/          # Páginas específicas con datos reales
```

## Niveles de Atomic Design

### 1. Atoms (Átomos)

**Ubicación:** `src/components/atoms/`

Componentes básicos, indivisibles y reutilizables. No dependen de otros componentes del proyecto.

**Ejemplos:**

- `Button`, `Input`, `Label`, `Icon`, `Avatar`, `Badge`, `Spinner`

**Características:**

- Componentes simples y atómicos
- Sin lógica de negocio compleja
- Altamente reutilizables
- Props simples y directas

**Ejemplo:**

```tsx
// src/components/atoms/Button/Button.component.tsx
import "./button.css";

interface ButtonProps {
  variant?: "primary" | "secondary";
  children: React.ReactNode;
  onClick?: () => void;
}

export const Button = ({ variant = "primary", children, onClick }: ButtonProps) => {
  return (
    <button className={`btn btn-${variant}`} onClick={onClick}>
      {children}
    </button>
  );
};
```

### 2. Molecules (Moléculas)

**Ubicación:** `src/components/molecules/`

Combinaciones de átomos que forman componentes funcionales simples.

**Ejemplos:**

- `SearchBox` (Input + Button)
- `FormField` (Label + Input + ErrorMessage)
- `Card` (con Header, Body, Footer como átomos)
- `NavItem` (Icon + Label)

**Características:**

- Combinan 2-5 átomos típicamente
- Tienen una función específica
- Pueden tener estado local simple
- Reutilizables en diferentes contextos

**Ejemplo:**

```tsx
// src/components/molecules/SearchBox/SearchBox.component.tsx
import "./searchbox.css";
import { Input } from "@/components/atoms/Input";
import { Button } from "@/components/atoms/Button";

export const SearchBox = ({ onSearch }: { onSearch: (query: string) => void }) => {
  const [query, setQuery] = useState("");

  return (
    <div className="search-box">
      <Input value={query} onChange={(e) => setQuery(e.target.value)} />
      <Button onClick={() => onSearch(query)}>Buscar</Button>
    </div>
  );
};
```

### 3. Organisms (Organismos)

**Ubicación:** `src/components/organisms/`

Componentes complejos que forman secciones distintivas de la interfaz.

**Ejemplos:**

- `Header` (con Logo, Navigation, UserMenu)
- `Sidebar` (con NavItems, UserProfile)
- `DataTable` (con TableHeader, TableRow, Pagination)
- `Form` (con múltiples FormFields y validación)

**Características:**

- Combinan moléculas y/o átomos
- Representan secciones completas de UI
- Pueden tener lógica de negocio
- Menos reutilizables que moléculas

**Ejemplo:**

```tsx
// src/components/organisms/Header/Header.component.tsx
import "./header.css";
import { Logo } from "@/components/atoms/Logo";
import { Navigation } from "@/components/molecules/Navigation";
import { UserMenu } from "@/components/molecules/UserMenu";

export const Header = () => {
  return (
    <header className="header">
      <Logo />
      <Navigation />
      <UserMenu />
    </header>
  );
};
```

### 4. Templates (Plantillas)

**Ubicación:** `src/components/templates/`

Layouts que definen la estructura y disposición de una página, sin datos específicos.

**Ejemplos:**

- `DashboardTemplate` (con Header, Sidebar, MainContent)
- `AuthTemplate` (con Logo centrado y formulario)
- `DocumentTemplate` (con Header, DocumentViewer, Comments)

**Características:**

- Definen la estructura de página
- Usan placeholders o props para contenido
- No contienen datos reales
- Muestran la disposición visual

**Ejemplo:**

```tsx
// src/components/templates/DashboardTemplate/DashboardTemplate.component.tsx
import "./dashboardtemplate.css";
import { Header } from "@/components/organisms/Header";
import { Sidebar } from "@/components/organisms/Sidebar";

interface DashboardTemplateProps {
  children: React.ReactNode;
}

export const DashboardTemplate = ({ children }: DashboardTemplateProps) => {
  return (
    <div className="dashboard-template">
      <Header />
      <div className="dashboard-content">
        <Sidebar />
        <main className="main-content">{children}</main>
      </div>
    </div>
  );
};
```

### 5. Pages (Páginas)

**Ubicación:** `src/components/pages/` o `src/pages/`

Instancias específicas de templates con datos reales y lógica de aplicación.

**Ejemplos:**

- `LoginPage`, `DashboardPage`, `DocumentListPage`

**Características:**

- Usan templates como base
- Contienen datos reales y lógica de negocio
- Pueden hacer llamadas a APIs
- Conectan componentes con el estado global

**Ejemplo:**

```tsx
// src/pages/DashboardPage.tsx
import { DashboardTemplate } from "@/components/templates/DashboardTemplate";
import { DocumentList } from "@/components/organisms/DocumentList";
import { useDocuments } from "@/hooks/useDocuments";

export const DashboardPage = () => {
  const { documents, loading } = useDocuments();

  return (
    <DashboardTemplate>
      <DocumentList documents={documents} loading={loading} />
    </DashboardTemplate>
  );
};
```

## Convenciones de Nomenclatura

- **Carpetas:** PascalCase que coincida con el nombre del componente (`Button/`, `SearchBox/`)
- **Componente:** `ComponentName.component.tsx` (ej: `Button.component.tsx`)
- **Estilos:** `component.css` en minúsculas (ej: `button.css`)
- **Tests:** `ComponentName.test.tsx` (opcional)
- **Exports:** Named exports preferidos (`export const Button`)
- **Props interfaces:** `ComponentNameProps` (ej: `ButtonProps`)

## Estructura de Archivo de Componente

Cada componente DEBE tener su propia carpeta con la siguiente estructura:

```
ComponentName/
  ComponentName.component.tsx    # Componente principal
  component.css                   # Estilos (en minúsculas)
  ComponentName.test.tsx         # Tests (opcional)
  index.ts                       # Re-export del componente
```

**Ejemplo:**

```
Button/
  Button.component.tsx
  button.css
  Button.test.tsx
  index.ts
```

**Ejemplo de código:**

```tsx
// src/components/atoms/Button/Button.component.tsx
import "./button.css";

export interface ButtonProps {
  variant?: "primary" | "secondary";
  children: React.ReactNode;
  onClick?: () => void;
}

export const Button = ({ variant = "primary", children, onClick }: ButtonProps) => {
  return (
    <button className={`btn btn-${variant}`} onClick={onClick}>
      {children}
    </button>
  );
};
```

```tsx
// src/components/atoms/Button/index.ts
export { Button } from "./Button.component";
export type { ButtonProps } from "./Button.component";
```

## Reglas de Importación

Usar path aliases para imports limpios:

```tsx
// ✅ GOOD
import { Button } from "@/components/atoms/Button";
import { SearchBox } from "@/components/molecules/SearchBox";

// ❌ BAD
import { Button } from "../../../atoms/Button";
```

## Cuándo Usar Cada Nivel

- **Atom:** ¿Es un elemento básico e indivisible? → Atom
- **Molecule:** ¿Combina 2-5 átomos con una función simple? → Molecule
- **Organism:** ¿Es una sección completa de UI? → Organism
- **Template:** ¿Define la estructura de una página? → Template
- **Page:** ¿Es una página específica con datos reales? → Page

## Principios

1. **Un componente por nivel:** No mezclar niveles en un mismo componente
2. **Composición sobre herencia:** Construir componentes complejos combinando simples
3. **Reutilización:** Los átomos y moléculas deben ser altamente reutilizables
4. **Separación de concerns:** La lógica de negocio va en páginas, no en átomos/moléculas
5. **Props drilling limitado:** Usar context o state management para datos compartidos entre niveles
